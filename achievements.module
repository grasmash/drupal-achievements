<?php

use Drupal\Core\Url;

/**
 * @file
 * Unlock achievements and earn points based on milestones.
 */

/**
 * Implements hook_theme().
 */
function achievements_theme() {
  $path = drupal_get_path('module', 'achievements') . '/templates';

  return [
    'achievement' => [
      'variables'       => ['achievement_entity' => NULL, 'unlock' => NULL],
      'template'        => 'achievement',
      'path'            => $path,
    ],
    'achievement_notification' => [
      'variables'       => ['achievement_entity' => NULL, 'unlock' => NULL],
      'template'        => 'achievement-notification',
      'path'            => $path,
    ],
    'achievement_latest_unlock' => [
      'variables'       => ['achievement_entity' => NULL, 'unlock' => NULL],
      'template'        => 'achievement-latest-unlock',
      'path'            => $path,
    ],
    'achievement_user_stats' => [
      'variables'       => ['stats' => NULL],
    ],
  ];
}

/**
 * Process variables for achievement.tpl.php.
 */
function template_preprocess_achievement(&$variables) {
  achievements_template_shared_variables($variables);
}

/**
 * Process variables for achievement-notification.tpl.php.
 */
function template_preprocess_achievement_notification(&$variables) {
  achievements_template_shared_variables($variables);
  $variables['classes'][] = 'element-hidden';
  $variables['classes'][] = 'achievement-notification';
}

/**
 * Process variables for achievement-latest-unlock.tpl.php.
 */
function template_preprocess_achievement_latest_unlock(&$variables) {
  achievements_template_shared_variables($variables);
}

/**
 * Default theme implementation for a user's achievement stats.
 *
 * @param variables
 *   An associative array containing:
 *   - stats: An array which contains the following keys:
 *     name, rank, points, unlocks_count, and total_count.
 */
function template_preprocess_achievement_user_stats(&$variables) {
  $variables['message'] = t('@name is ranked #@rank with @points points. @unlocks_count of @total_count achievements have been unlocked.', array(
    '@name'           => $variables['stats']['name'],
    '@rank'           => $variables['stats']['rank'],
    '@points'         => $variables['stats']['points'],
    '@unlocks_count'  => $variables['stats']['unlocks_count'],
    '@total_count'    => $variables['stats']['total_count'],
  ));
}

/**
 * Standard variables used in our achievement templates.
 *
 * All our achievement templates send in $achievement and $unlock, but display
 * some or all of the data in different ways. This is a centralized collection
 * of the various helper $variables needed for theme display.
 */
function achievements_template_shared_variables(&$variables) {
  /** @var \Drupal\achievements\Entity\AchievementEntity $achievement */
  $achievement = $variables['achievement_entity'];
  $variables['state'] = isset($variables['unlock']) ? 'unlocked' : 'locked';
  $variables['classes'][] = 'achievement';
  $variables['classes'][] = 'achievement-' . $variables['state'];
  $variables['classes'][] = 'ui-corner-all'; // add rounded rects for tabs.
  $variables['achievement_url'] =   $url = Url::fromUri('internal:/achievements/leaderboard/' . $achievement->id());

  if ($achievement->isSecret()
    && !achievements_unlocked_already($achievement->id())) {
    $achievement->set('points', t('???'));
    $achievement->set('title', t('Secret achievement'));
    $achievement->set('destcription', t('Continue playing to unlock this secret achievement.'));
    $variables['state'] = 'secret';
  }

  $variables['image'] = [
    '#theme' => 'image_formatter',
    '#item' => (object) [
      // @todo Add path dynamically!
      'uri'   => $achievement->getImagePath(),
      'alt'   => $achievement->label(),
      'title' => $achievement->label(),
      'width' => 70,
      'height' => 70,
      'entity' => FALSE,
    ],
    '#path' => [
      'path'    => 'achievements/leaderboard/' . $achievement->id(),
      'options' => ['html' => TRUE],
    ],
  ];

  $variables['achievement_title'] = [
    '#type'   => 'link',
    '#title'  => $achievement->label(),
    '#url'   => Url::fromUri('internal:/achievements/unlocks/' . $achievement->id()),
  ];
  $variables['achievement_points'] = [
    '#markup' => t('@points points', ['@points' => $achievement->getPoints()]),
  ];
  $variables['unlocked_date'] = [
    '#markup' => isset($variables['unlock']['timestamp'])
      ? format_date($variables['unlock']['timestamp'], 'custom', 'Y/m/d')
      : '',
  ];
  $variables['unlocked_rank'] = [
    '#markup' => isset($variables['unlock']['rank'])
      ? t('Rank #@rank', ['@rank' => $variables['unlock']['rank']])
      : '',
  ];
}

/**
 * @param int $achievement_id
 *
 * @return \Drupal\achievements\Entity\AchievementEntity
 */
function achievements_load($achievement_id) {
  $achievements = achievements_load_all();
  return $achievements[$achievement_id];
}

function achievements_load_all($reset = FALSE) {
  $achievements = &drupal_static(__FUNCTION__);
  if (!isset($achievements) || $reset) {
    /** @var \Drupal\achievements\Entity\AchievementEntity[] $achievements */
    $achievements = \Drupal::entityTypeManager()
      ->getStorage('achievement_entity')
      ->loadMultiple();
  }

  return $achievements;
}

/**
 * Logs a user as having unlocked an achievement.
 *
 * @param $achievement_id
 *   The achievement this request applies against.
 * @param $uid
 *   The user to unlock an achievement for (defaults to current user).
 * @param $timestamp
 *   Optional; the timestamp when this achievement was unlocked.
 */
function achievements_unlocked($achievement_id, $uid = NULL, $timestamp = REQUEST_TIME) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  if (!$access) {
    return FALSE;
  }

  $achievement = achievements_load($achievement_id);

  if (is_null($achievement)) {
    \Drupal::logger('achievements')
      ->error('%achievement_id is not a valid achievement ID.', ['%achievement_id' => $achievement_id]);
    return FALSE;
  }

  if (!achievements_unlocked_already($achievement_id, $uid)) {
    $last_rank = db_select('achievement_unlocks', 'au')
      ->fields('au', ['rank'])
      ->condition('achievement_id', $achievement_id)
      ->orderBy('rank', 'DESC')
      ->range(0, 1)
      ->execute()
      ->fetchField();

    db_insert('achievement_unlocks')
      ->fields([
        'achievement_id'  => $achievement_id,
        'uid'             => $uid,
        'rank'            => $last_rank ? $last_rank + 1 : 1,
        'timestamp'       => $timestamp,
        'seen'            => 0,
      ])
      ->execute();

    db_merge('achievement_totals')
      ->key(['uid' => $uid])
      ->fields([
        'points'          => $achievement->getPoints(),
        'unlocks'         => 1, // OMG CONGRATS
        'timestamp'       => $timestamp,
        'achievement_id'  => $achievement_id,
      ])
      ->expression('points', 'points + :points', [':points' => $achievement->getPoints()])
      ->expression('unlocks', 'unlocks + :increment', [':increment' => 1])
      ->execute();

    // update the unlocked_already static cache so that it returns accurate
    // unlocks for the rest of the page load. we could have just reset the
    // cache entirely but that would cost us additional database queries
    // based on the number of unique unlocks in this page load.
    $unlocks = &drupal_static('achievements_unlocked_already');
    $unlocks[$uid][$achievement_id] = [
      'achievement_id'  => $achievement_id,
      'rank'            => $last_rank ? $last_rank + 1 : 1,
      'timestamp'       => $timestamp,
    ];

    \Drupal::moduleHandler()->invokeAll('achievements_unlocked', [$achievement, $uid]);

    // @FIXME
// l() expects a Url object, created from a route name or external URI.
// watchdog('achievements', 'Unlocked: %achievement (+@points).',
//       array('%achievement' => $achievement['title'], '@points' => $achievement['points']),
//       WATCHDOG_NOTICE, l(t('view'), 'user/' . $uid . '/achievements'));
 // nothing fancy.
  }
}

/**
 * Return data about a user's unlocked achievements.
 *
 * @param $achievement_id
 *   A specific achievement to check the unlock status of.
 * @param $uid
 *   The user this request applies against (defaults to current user).
 *
 * @return array|NULL or $unlocked or $unlocks
 *   One of the following, based on the passed parameters:
 *   - If the $uid has not unlocked $achievement_id, return NULL.
 *   - If $achievement_id is unlocked, return an array of rank and timestamp.
 *   - If no $achievement_id is passed, an array of all $uid's unlocks.
 */
function achievements_unlocked_already($achievement_id = NULL, $uid = NULL) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  if (!$access) {
    return;
  }
  $unlocks = &drupal_static(__FUNCTION__, []);

  if (!array_key_exists($uid, $unlocks)) {
    // We grab all unlocks and cache per page load.
    // It's better than lots of per-achievement lookups.
    $unlocks[$uid] = db_select('achievement_unlocks', 'au')
      ->fields('au', ['achievement_id', 'rank', 'timestamp'])
      ->condition('uid', $uid)
      ->execute()
      ->fetchAllAssoc('achievement_id', PDO::FETCH_ASSOC);
  }

  if (isset($achievement_id)) {
    return isset($unlocks[$uid][$achievement_id]) ? $unlocks[$uid][$achievement_id] : NULL;
  }
  else { // all of 'em.
    return $unlocks[$uid];
  }
}

/**
 * Returns a user-centric leaderboard.
 *
 * @param $nearby
 *   How many nearby ranks/users should be returned (defaults to 0).
 * @param $uid
 *   The user to return achievement info for (defaults to current user).
 *
 * @return $results
 *   Either an empty array (for users who have yet to unlock anything) or
 *   or an array of user(s) and their achievement statistics, keyed to uid.
 */
function achievements_totals_user($uid = NULL) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  // we don't check for access as this is info grubbing only.

  $achievers = &drupal_static(__FUNCTION__);
  $leaderboard_table = 'achievement_totals';

  if (!isset($achievers[$uid])) {
    $query = db_select('achievement_totals', 'at');
    $query->addTag('achievement_totals_user')
      ->join('users_field_data', 'u', 'u.uid = at.uid');
    $query->fields('at', [
        'uid',
        'points',
        'unlocks',
        'timestamp',
        'achievement_id',
      ])
      ->fields('u', ['name']);
    $achievers[$uid] = $query->condition('at.uid', $uid)
      ->execute()
      ->fetchObject();

    // Get user's oveall rank.
    if (isset($achievers[$uid]->points)) {
      // Only if they've unlocked something.
      // To find the user's rank: count all the users with greater points, add
      // all the users with equal points but earlier timestamps, and then add 1.
      $better_points = db_select('achievement_totals')
        ->condition('points', $achievers[$uid]->points, '>')
        ->countQuery()
        ->execute()
        ->fetchField();
      $earlier_times = db_select('achievement_totals')
        ->condition('points', $achievers[$uid]->points)
        ->condition('timestamp', $achievers[$uid]->timestamp, '<')
        ->countQuery()
        ->execute()
        ->fetchField();
      $achievers[$uid]->rank = $better_points + $earlier_times + 1;
    }
  }

  return isset($achievers[$uid]->points) ? $achievers : [];
}

/**
 * Relocks (or "takes away") an achievement from a user.
 *
 * @param $achievement_id
 *   The achievement this request applies against.
 * @param $uid
 *   The user to relock an achievement for (defaults to current user).
 */
function achievements_locked($achievement_id, $uid = NULL) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  if (!$access) {
    return;
  }

  // Only remove the achievement if the user has unlocked it.
  if (achievements_unlocked_already($achievement_id, $uid)) {
    $achievement = achievements_load($achievement_id); // we need the full thing so we know how many points to take away.
    db_delete('achievement_unlocks')
      ->condition('achievement_id', $achievement['id'])
      ->condition('uid', $uid)
      ->execute();

    // Load up a previous unlock if they've got one.
    $previous_unlock = db_select('achievement_unlocks')
      ->fields('achievement_unlocks', ['achievement_id'])
      ->condition('uid', $uid)
      ->orderBy('timestamp', 'DESC')
      ->range(0, 1)
      ->execute()
      ->fetchField();

    if ($previous_unlock) {
      db_update('achievement_totals') // subtract points and set the previous unlock as their latest.
        ->fields(['uid' => $uid, 'timestamp' => REQUEST_TIME, 'achievement_id' => $previous_unlock])
        ->expression('points', 'points - :points', [':points' => $achievement['points']])
        ->expression('unlocks', 'unlocks - :decrement', [':decrement' => 1])
        ->condition('uid', $uid)
        ->execute();
    }
    else { // With no previous unlock, remove from leaderboard entirely.
      db_delete('achievement_totals')
        ->condition('uid', $uid)
        ->execute();
    }

    // remove any storage associated with this achievement.
    achievements_storage_del($achievement['id'], $uid);
    \Drupal::moduleHandler()->invokeAll('achievements_locked', [$achievement, $uid]);
  }
}

/**
 * Retrieve data needed by an achievement.
 *
 * @param $achievement_id
 *   An identifier for the achievement whose data is being collected.
 * @param $uid
 *   The user this stored data applies to (defaults to current user).
 *
 * @return $data
 *   The data stored for this achievement and user (unserialized).
 */
function achievements_storage_get($achievement_id = NULL, $uid = NULL) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  if (!$access) {
    return;
  }

  return unserialize(db_select('achievement_storage')
    ->fields('achievement_storage', ['data'])
    ->condition('achievement_id', $achievement_id)
    ->condition('uid', $uid)
    ->execute()
    ->fetchField());
}

/**
 * Save data needed by an achievement.
 *
 * @param $achievement_id
 *   An identifier for the achievement whose data is being collected.
 * @param $uid
 *   The user this stored data applies to (defaults to current user).
 * @param $data
 *   The data being saved (of any type; serialization occurs).
 */
function achievements_storage_set($achievement_id = NULL, $data = NULL, $uid = NULL) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  if (!$access) {
    return;
  }

  $connection = \Drupal::database();
  $connection->merge('achievement_storage')
    ->key([
      'uid' => $uid,
      'achievement_id' => $achievement_id
    ])
    ->fields(['data' => serialize($data)])
    ->execute();
}

/**
 * Delete data stored by an achievement.
 *
 * @param $achievement_id
 *   An identifier for the achievement whose data is being collected.
 * @param $uid
 *   The user this stored data applies to (defaults to current user).
 */
function achievements_storage_del($achievement_id = NULL, $uid = NULL) {
  list($uid, $access) = achievements_user_is_achiever($uid);
  if (!$access) { return; }

  $achievement = achievements_load($achievement_id);
  $storage = isset($achievement['storage']) ? $achievement['storage'] : $achievement['id'];
  db_delete('achievement_storage')
    ->condition('achievement_id', $storage)
    ->condition('uid', $uid)
    ->execute();
}

/**
 * Determine if a user is able to earn achievements.
 *
 * This is a general helper around the core achievements functions and allows
 * us to default to the global user if a $uid is not passed, but also check
 * permissions against a user who is not the global user. This allows us to
 * a) define roles of users that can not earn achievements and b) manually
 * unlock achievements for a non-current user.
 *
 * @param $uid
 *   The user to check for "earn achievements" (defaults to current user).
 *
 * @return $results
 *   An array with values of:
 *   - $uid is the determined user (default: the global user).
 *   - $access is a TRUE or FALSE determined by user_access() and hooks.
 */
function achievements_user_is_achiever($uid = NULL) {
  $is_achiever = &drupal_static(__FUNCTION__, []);
  $uid = isset($uid) ? $uid : \Drupal::currentUser()->id();

  if (!array_key_exists($uid, $is_achiever)) {
    if ($uid == \Drupal::currentUser()->id()) { // if $uid is current user, check normally.
      $is_achiever[$uid] = [\Drupal::currentUser()->id(), \Drupal::currentUser()->hasPermission('earn achievements')];
    }
    else { // if it's not the global user, we need to load them fully, then check.
      $is_achiever[$uid] = [$uid, \Drupal::currentUser()->hasPermission('earn achievements')];
    }

    // Let other modules decide if this user can earn achievements. Hook
    // results take precedence over the standard user_access() because we
    // treat code prowess as stronger rationale than simplistic UI clicking.
    $module_access = \Drupal::moduleHandler()->invokeAll('achievements_access_earn', [$uid]);

    if (in_array(TRUE, $module_access, TRUE)) {
      $is_achiever[$uid] = [$uid, TRUE];
    }
    elseif (in_array(FALSE, $module_access, TRUE)) {
      $is_achiever[$uid] = [$uid, FALSE];
    }
  }

  return $is_achiever[$uid];
}

/**
 * Implements hook_user_cancel().
 */
function achievements_user_cancel($edit, $account, $method) {
  achievements_user_delete($account); // no stats for non-players.
}

/**
 * Implements hook_user_delete().
 */
function achievements_user_delete(\Drupal\user\UserInterface $account) {
  db_delete('achievement_totals')->condition('uid', $account->id())->execute();
  db_delete('achievement_unlocks')->condition('uid', $account->id())->execute();
  db_delete('achievement_storage')->condition('uid', $account->id())->execute();
}

/**
 * Implements hook_page_alter().
 */
function achievements_page_bottom(array &$page_bottom) {
  // Achievement popups won't show if the overlay is active, so we'll defer until it isn't.
  // See http://drupal.stackexchange.com/questions/35382/hide-module-when-path-is-overlay.
  if (achievements_user_is_achiever()) {
    $unlocks = db_select('achievement_unlocks', 'au')
      ->fields('au', [
          'achievement_id',
          'rank',
          'timestamp'
        ])
      ->condition('uid', \Drupal::currentUser()->id())
      ->condition('seen', 0)
      ->orderBy('timestamp')
      ->execute()
      ->fetchAllAssoc('achievement_id', PDO::FETCH_ASSOC);

    // if unseen unlocks are available, load in our JS libraries,
    // display our achievement notification, and flag 'em as seen.
    if (count($unlocks)) {
      foreach ($unlocks as $unlock) {
        $achievement = achievements_load($unlock['achievement_id']);
        $page_bottom['achievements'][$unlock['achievement_id']] = [
          '#theme'        => 'achievement_notification',
          '#achievement_entity'  => $achievement,
          '#unlock'       => $unlock,
          '#attached'     => [
            'library'     => [
              'achievements/achievements',
            ],
          ],
        ];
      }

      db_update('achievement_unlocks')
        ->fields(['seen' => 1])
        ->condition('uid', \Drupal::currentUser()->id())
        ->condition('seen', 0)
        ->execute();
    }
  }
}

/**
 * Implements hook_views_data().
 */
function achievements_views_data() {
  $data = [];

  $join = [
    'users_field_data' => [
      'type' => 'INNER',
      'left_field' => 'uid',
      'left_table' => 'users_field_data',
      'field' => 'uid',
    ],
  ];
  $achievement_id = array(
    'title' => t("Achievement ID"),
    'help' => t(''),
    'field' => array(
      'id' => 'standard',
    ),
    'argument' => [
      'id' => 'achievement_id',
    ],
  );
  $config = array(
    'title' => t("Achievement Config"),
    'help' => t('Configuration for the achievement.'),
    'real field' => 'achievement_id',
    'field' => array(
      'id' => 'achievement_config',
    ),
  );
  $uid = [
    'title' => t('User ID'),
    'help' => t('The user ID of the achiever.'),
    'field' => [
      'id' => 'numeric',
    ],
    'argument' => [
      'id' => 'user_uid',
    ],
    'filter' => [
      'title' => t('User ID'),
      'id' => 'user_name',
    ],
    'sort' => [
      'id' => 'standard',
    ],
    'relationship' => [
      'base' => 'users_field_data',
      'base field' => 'uid',
      'id' => 'standard',
      'label' => t('User'),
    ],
  ];
  $timestamp = [
    'title' => t('Timestamp'),
    'help' => t('The date the node was last updated.'),
    'field' => [
      'id' => 'date',
    ],
    'sort' => [
      'id' => 'date',
    ],
    'filter' => [
      'id' => 'date',
    ],
  ];

  $data['achievement_storage'] = [];
  $data['achievement_storage']['table'] = [];
  $data['achievement_storage']['table']['group'] = t('Achievements Storage');
  $data['achievement_storage']['table']['base'] = array(
    'field' => 'uid',
    'title' => t('User achievement storage data'),
    'help' => t(''),
    'weight' => -10,
  );
  $data['achievement_storage']['table']['join'] = $join;
  $data['achievement_storage']['uid'] = $uid;
  $data['achievement_storage']['data'] = [
    'title' => t('Data'),
    'help' => t(''),
    'field' => [
      'id' => 'serialized',
    ],
  ];

  $data['achievement_totals'] = [];
  $data['achievement_totals']['table'] = [];
  $data['achievement_totals']['table']['group'] = t('Achievements Totals');
  $data['achievement_totals']['table']['base'] = array(
    'field' => 'uid',
    'title' => t('User achievement totals'),
    'help' => t(''),
    'weight' => -10,
  );
  $data['achievement_totals']['table']['join'] = $join;
  $data['achievement_totals']['uid'] = $uid;
  $data['achievement_totals']['timestamp'] = $timestamp;
  $data['achievement_totals']['config'] = $config;
  $data['achievement_totals']['achievement_id'] = $achievement_id;
  $data['achievement_totals']['points'] = array(
    'title' => t('Points'),
    'help' => t('Just a numeric field.'),
    'field' => array(
      'id' => 'numeric',
      'click sortable' => TRUE,
    ),
    'sort' => array(
      'id' => 'standard',
    ),
    'filter' => array(
      'id' => 'numeric',
    ),
    'argument' => array(
      'id' => 'numeric',
    ),
  );
  $data['achievement_totals']['unlocks'] = array(
    'title' => t('Unlocks'),
    'help' => t('Just a numeric field.'),
    'field' => array(
      'id' => 'numeric',
      'click sortable' => TRUE,
    ),
    'sort' => array(
      'id' => 'standard',
    ),
    'filter' => array(
      'id' => 'numeric',
    ),
    'argument' => array(
      'id' => 'numeric',
    ),
  );
  $data['achievement_totals']['latest_achievement'] = [
    'title' => t('Latest achievement for user'),
    'help' => t(''),
    'real field' => 'uid',
    'field' => [
      'id' => 'latest_achievement',
    ],
    'relationship' => [
      'base' => 'users_field_data',
      'base field' => 'uid',
      'id' => 'standard',
      'label' => t('User'),
    ],
  ];

  $data['achievement_unlocks'] = [];
  $data['achievement_unlocks']['table'] = [];
  $data['achievement_unlocks']['table']['group'] = t('Achievements Unlocks');
  $data['achievement_unlocks']['table']['base'] = array(
    'field' => 'uid',
    'title' => t('User achievement unlocks'),
    'help' => t(''),
    'weight' => -10,
  );
  $data['achievement_unlocks']['table']['join']  = $join;
  $data['achievement_unlocks']['config']         = $config;
  $data['achievement_unlocks']['achievement_id'] = $achievement_id;
  $data['achievement_unlocks']['uid']            = $uid;
  $data['achievement_unlocks']['timestamp']      = $timestamp;
  $data['achievement_unlocks']['rank'] = array(
    'title' => t('Rank'),
    'help' => t('Just a numeric field.'),
    'field' => array(
      'id' => 'numeric',
      'click sortable' => TRUE,
    ),
    'sort' => array(
      'id' => 'standard',
    ),
    'filter' => array(
      'id' => 'numeric',
    ),
    'argument' => array(
      'id' => 'numeric',
    ),
  );
  $data['achievement_unlocks']['seen'] = array(
    'title' => t('Seen'),
    'help' => t('Has the user seen the achievement?'),
    'field' => array(
      'id' => 'boolean',
      'click sortable' => TRUE,
    ),
    'sort' => array(
      'id' => 'standard',
    ),
    'filter' => array(
      'id' => 'boolean',
    ),
    'argument' => array(
      'id' => 'numeric',
    ),
  );


  return $data;
}
